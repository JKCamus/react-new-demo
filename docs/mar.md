6、霰弹式修改
如果每遇到某种变化，你都必须在许多不同的类作出小修改，你所面临的坏味道就是，你如果需要修改代码有很多处，你不但很难找到它们,也很容易忘记某个重要的修改。
这种情况下你应该使用迁移函数和搬移字段把所有需要修改的代码放进同一个类。如果眼下没有合适的类，就创造一个。如果将代码移动到同一个类，使原始类几乎为空，请尝试通过将类内联化摆脱这些现在多余的类。
发散式变化是指"一个类受多种变化的影响"，霰弹式修改是指"一种变化引入引发多个类的修改"。这两种情况下，你都会希望整理代码，使"外界变化"与"需要修改的类"趋于一一对应

7、依恋情结
函数对于某个类的兴趣高过对自己所处类的兴趣。
把这个函数移至另一个地点，移到它该去的地方。迁搬移函数
如果一个函数用到几个类的功能，则该判断哪个类拥有最多被此函数使用的数据，然后就把这个函数和那些数据摆在一起。提炼函数，搬移函数

8、数据泥团
数据项就像小孩子，总喜欢成群结对地的待在一块，如果删掉众多数据中的一项，其他数据因而失去意义,就应该为它们产生一个新对象

1. 如果一个类里有很多有关系的数据字段,那么就要考虑为这些有关系的数据建立一个新家。提炼类创建数据新对象
2. 如果函数参数引用很多有关系的字段,那么就要考虑让这些分散的参数变成参数对象，引用参数对象。
3. 如果一个函数的参数来自同一个对象的若干个属性，可以考虑引用对象。因为如果被调用的的函数改变参数，必须查找并修改这个函数的所有调用保持对象完整
   第二点与第三点类似，只不过第二点需要新建一个类来声明字段，第三点不用

9、基本类型偏执
简单一句话就是只喜欢在原代码的基础上加基本类型字段，不喜欢提取对象
可以运用以对象取代数据值将原本单独存在的数据值替换为对象。
如果想要替换的数据值是类型码，而它不影响行为，则可以运用以类取代类型码将它换掉。
如果你有与类型码相关的条件表达式可以运用以子类取代类型码或者以取代类型码加以处理。
如果你有一组总是被放在一起的字段，可以运用提炼类
如果在参数列中看到基本数据类型，不妨试试引用参数对象
如果你发现自己正从数组中挑选数据,可以运用以对象取代数组

10、Switch 惊悚现身
你常会发现 switch 语句散布于不同地点。如果要为它添加一个新的 case 子句，就必须找到所有 switch 语句并修改它们。面向对象中的多态概念可为此带来优雅的解决办法。
条件表达式，它根据类型的不同而选择不同的行为。以多态取代条件表达式
有个类型码，它会影响行为，但你无法通过继承的方式消除它，或者类型码的数值在对象的生命周期中发生变化以状态/策略取代类型码
如果单一函数 有些选择事例,且不想改动它们,那么多态就有点杀鸡用牛刀了，以明确函数取代参数

11、平行继承体系
平行继承体系其实是散弹式修改的特殊情况。这种情况下，每当你为某个类增加一个子类，必须也为另一个类相应增加一个子类。如果你发现某个继承体系的类名称前缀和另一个继承体系的类名称前缀完全相同，便是闻到了这种坏味道
让一个继承体系的实例引用另一个继承体系的实例，,如果在运用搬移函数和搬移字段就可以将引用端的继承体系消弭于无形

12、冗赘类
如果一个类的所得并不值其身价，他就应该消失。项目中经常会出现这样的情况：某个类原本对得起自己的价值，但重构使它身形缩水，不再做那么多工作；或开发者事先规划了某些变化，并添加一个类来应付这些变化，但变化实际没有发生。
如果某些子类没有做足够的工作，使用折叠继承体系
对于几乎没用的组件，使用将类内联化

13、夸夸其谈未来性
如果这段代码当前用不到，就删掉它
如果你的某个抽象类没有太大作用，请用折叠继承体系
不必要的委托可以用将类内联化除掉
如果函数的某些参数未被用上，可对它实施移除参数
如果函数名带有多余的抽象意味，应该对它实施函数改名

14、令人迷惑的暂时字段
如果类中有一个复杂算法，需要好几个变量，往往就可能导致坏味道令人迷惑的临时字段出现。由于实现者不希望传递一长串参数，所以他把这些参数都放进字段。但是这些字段只在使用该算法时才有效，其他情况下只会让人迷惑。
这时可以利用提炼类把这些变量和其相关函数提炼到一个独立的类中。

15、过度耦合的消息链
如果你看到用户向一个对象请求另一个对象,然后在向后者请求另一个对象，然后在请求另一个对象类似： getPerson().getDepartment().getAddress().getStreet() 就是消息链

使用 Hide Delegate（隐藏委托关系）。理论上讲可以重构消息链上的任何一个对象，但这么做会把一系列对象都变成中间人（Middle Man）。
先观察消息链最终得到对象来干什么，看能否以提炼函数把使用该对象的代码提炼到一个独立的函数中，再用 Move Method（搬移函数）把这个函数推入消息链
